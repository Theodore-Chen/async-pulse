<div align="center">

# âš¡ AsyncPulse

**é«˜æ€§èƒ½ C++ å¹¶å‘ç¼–ç¨‹å·¥å…·åº“**

[![C++17](https://img.shields.io/badge/C%2B%2B-17-blue.svg)](https://isocpp.org/std/the-standard)
[![CMake](https://img.shields.io/badge/CMake-3.20%2B-green.svg)](https://cmake.org)
[![License](https://img.shields.io/badge/License-Apache%202.0-yellow.svg)](LICENSE)

<p align="center">
  <b>æ— é”æ•°æ®ç»“æ„</b> â€¢
  <b>é€šç”¨çŠ¶æ€æœº</b> â€¢
  <b>é«˜æ€§èƒ½çº¿ç¨‹æ± </b> â€¢
  <b>å®‰å…¨å†…å­˜å›æ”¶</b>
</p>

</div>

---

## ğŸš€ ç®€ä»‹

**AsyncPulse** æ˜¯ä¸€ä¸ªä¸“æ³¨äºé«˜æ€§èƒ½å¹¶å‘ç¼–ç¨‹çš„ç°ä»£åŒ– C++ åº“ã€‚å®ƒæä¾›äº†ä¸€ç³»åˆ—ç»è¿‡ç²¾å¿ƒè®¾è®¡å’Œå……åˆ†æµ‹è¯•çš„å¹¶å‘ç»„ä»¶ï¼Œå¸®åŠ©å¼€å‘è€…æ„å»ºé«˜ååã€ä½å»¶è¿Ÿçš„å¤šçº¿ç¨‹åº”ç”¨ã€‚

æ ¸å¿ƒè®¾è®¡ç†å¿µï¼š
- **æ— é”ä¼˜å…ˆ**ï¼šå°½å¯èƒ½ä½¿ç”¨æ— é”ç®—æ³•ï¼Œé¿å…çº¿ç¨‹é˜»å¡
- **ç¼“å­˜å‹å¥½**ï¼šç²¾å¿ƒè®¾è®¡å†…å­˜å¸ƒå±€ï¼Œå‡å°‘ä¼ªå…±äº«
- **ç±»å‹å®‰å…¨**ï¼šå……åˆ†åˆ©ç”¨ C++17 ç‰¹æ€§ï¼Œç¼–è¯‘æœŸæ•è·é”™è¯¯
- **é›¶å¼€é”€æŠ½è±¡**ï¼šé«˜æ€§èƒ½ä¸ä¼˜é›… API çš„å®Œç¾ç»“åˆ

---

## âœ¨ æ ¸å¿ƒç‰¹æ€§

### ğŸ“¦ æ— é”é˜Ÿåˆ— (Lock-Free Queues)

| é˜Ÿåˆ—ç±»å‹ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|---------|------|---------|
| `lock_free_bounded_queue` | æœ‰ç•Œç¯å½¢ç¼“å†²åŒºï¼Œç¼“å­˜è¡Œå¯¹é½ | å›ºå®šå®¹é‡ã€æè‡´æ€§èƒ½éœ€æ±‚ |
| `ms_queue` | Michael-Scott æ— é”é˜Ÿåˆ—ç®—æ³• | é«˜å¹¶å‘ç”Ÿäº§è€…-æ¶ˆè´¹è€…åœºæ™¯ |
| `lock_queue` | åŸºäºäº’æ–¥é”çš„ä¼ ç»Ÿå®ç° | å…¼å®¹æ€§ã€ç®€å•åœºæ™¯ |

```cpp
#include "queue/ms_queue.h"

// æ— é”é˜Ÿåˆ— - å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…
ms_queue<int> queue;

// ç”Ÿäº§è€…çº¿ç¨‹
queue.enqueue(42);

// æ¶ˆè´¹è€…çº¿ç¨‹
auto val = queue.dequeue();  // è¿”å› std::optional<int>
if (val) {
    std::cout << "Got: " << *val << std::endl;
}
```

### ğŸ¯ æœ‰é™çŠ¶æ€æœº (FSM)

```cpp
#include "fsm/fsm.h"

// å®šä¹‰çŠ¶æ€å’Œäº‹ä»¶
enum class State { Idle, Running, Stopped };
enum class Event { Start, Stop, Reset };

// åˆ›å»ºçŠ¶æ€è½¬æ¢è¡¨
StateTable<State, Event> table;
// ... é…ç½®çŠ¶æ€å›è°ƒ

// å¯åŠ¨çŠ¶æ€æœº
FSM<State, Event> fsm(&table, &changeTable, State::Idle);

// å‘é€äº‹ä»¶å¹¶ç­‰å¾…å¤„ç†å®Œæˆ
std::future<void> done = fsm.Submit(Event::Start);
done.wait();
```

**è®¾è®¡ä¼˜åŠ¿**ï¼š
- å•çº¿ç¨‹äº‹ä»¶å¤„ç†ï¼Œæ— æ•°æ®ç«äº‰
- æ”¯æŒè¿›å…¥/é€€å‡º/å›è°ƒä¸‰ç§çŠ¶æ€åŠ¨ä½œ
- ç±»å‹å®‰å…¨çš„çŠ¶æ€è½¬æ¢

### ğŸ§µ é«˜æ€§èƒ½çº¿ç¨‹æ±  (Thread Pool)

```cpp
#include "thread_pool/thread_pool.h"

// åˆ›å»ºå¤„ç†æ•°æ®çš„çº¿ç¨‹æ± 
ThreadPool<Data> pool(4, [](Data& data) {
    // å¤„ç†æ•°æ®
    data.process();
});

// æäº¤ä»»åŠ¡å¹¶è·å–ç»“æœ
std::future<Data> result = pool.Submit(std::move(my_data));
Data processed = result.get();
```

**ç‰¹æ€§äº®ç‚¹**ï¼š
- æ¨¡æ¿åŒ–è®¾è®¡ï¼Œé›¶æ‹·è´å¼€é”€
- è‡ªåŠ¨çº¿ç¨‹ç®¡ç†ï¼ˆRAIIï¼‰
- æ”¯æŒ `std::future` è·å–å¼‚æ­¥ç»“æœ
- ä¼˜é›…çš„å…³é—­æœºåˆ¶

```cpp
#include "fsm/fsm.h"

// å®šä¹‰çŠ¶æ€å’Œäº‹ä»¶
enum class State { Idle, Running, Stopped };
enum class Event { Start, Stop, Reset };

// åˆ›å»ºçŠ¶æ€è½¬æ¢è¡¨
StateTable<State, Event> table;
// ... é…ç½®çŠ¶æ€å›è°ƒ

// å¯åŠ¨çŠ¶æ€æœº
FSM<State, Event> fsm(&table, &changeTable, State::Idle);

// å‘é€äº‹ä»¶å¹¶ç­‰å¾…å¤„ç†å®Œæˆ
std::future<void> done = fsm.Submit(Event::Start);
done.wait();
```

**è®¾è®¡ä¼˜åŠ¿**ï¼š
- å•çº¿ç¨‹äº‹ä»¶å¤„ç†ï¼Œæ— æ•°æ®ç«äº‰
- æ”¯æŒè¿›å…¥/é€€å‡º/å›è°ƒä¸‰ç§çŠ¶æ€åŠ¨ä½œ
- ç±»å‹å®‰å…¨çš„çŠ¶æ€è½¬æ¢

### ğŸ›¡ï¸ å®‰å…¨å†…å­˜å›æ”¶ (Hazard Pointer)

åŸºäº Hazard Pointer çš„ SMRï¼ˆSafe Memory Reclamationï¼‰å®ç°ï¼š

```cpp
#include "hp/hp.h"

// æ— é”æ•°æ®ç»“æ„çš„å†…å­˜å®‰å…¨å›æ”¶
// è‡ªåŠ¨ç®¡ç† retire èŠ‚ç‚¹çš„ç”Ÿå‘½å‘¨æœŸ
// æ”¯æŒæ‰¹é‡å›æ”¶ï¼Œå‡å°‘å¼€é”€
```

---

## ğŸ—ï¸ é¡¹ç›®ç»“æ„

```
async-pulse/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ queue/           # é˜Ÿåˆ—å®ç°
â”‚   â”‚   â”œâ”€â”€ ms_queue.h              # Michael-Scott æ— é”é˜Ÿåˆ—
â”‚   â”‚   â”œâ”€â”€ lock_free_bounded_queue.h  # æœ‰ç•Œæ— é”é˜Ÿåˆ—
â”‚   â”‚   â””â”€â”€ lock_queue.h            # åŸºäºé”çš„é˜Ÿåˆ—
â”‚   â”œâ”€â”€ thread_pool/     # çº¿ç¨‹æ± å®ç°
â”‚   â”‚   â”œâ”€â”€ thread_pool.h           # é«˜æ€§èƒ½æ¨¡æ¿çº¿ç¨‹æ± 
â”‚   â”‚   â””â”€â”€ thread_pool_bind.h      # çµæ´»ç»‘å®šçº¿ç¨‹æ± 
â”‚   â”œâ”€â”€ fsm/             # çŠ¶æ€æœºå®ç°
â”‚   â”‚   â””â”€â”€ fsm.h                   # é€šç”¨æœ‰é™çŠ¶æ€æœº
â”‚   â”œâ”€â”€ hp/              # Hazard Pointer å†…å­˜å›æ”¶
â”‚   â”‚   â”œâ”€â”€ hp.h
â”‚   â”‚   â”œâ”€â”€ smr.h
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ opt/             # ä¼˜åŒ–å·¥å…·
â”‚       â”œâ”€â”€ cache_line.h            # ç¼“å­˜è¡Œå¯¹é½
â”‚       â””â”€â”€ back_off.h              # é€€é¿ç­–ç•¥
â”œâ”€â”€ test/                # æµ‹è¯•å¥—ä»¶
â”‚   â”œâ”€â”€ unit/            # å•å…ƒæµ‹è¯•
â”‚   â””â”€â”€ stress/          # å‹åŠ›æµ‹è¯•
â””â”€â”€ benchmark/           # æ€§èƒ½åŸºå‡†æµ‹è¯•
```

---

## ğŸ”§ ç¼–è¯‘ä¸ä½¿ç”¨

### ç¯å¢ƒè¦æ±‚

- **ç¼–è¯‘å™¨**: GCC 13+ / Clang 16+
- **CMake**: 3.20 æˆ–æ›´é«˜ç‰ˆæœ¬
- **C++æ ‡å‡†**: C++17

### å¿«é€Ÿå¼€å§‹

```bash
# å…‹éš†ä»“åº“
git clone <repo-url>
cd async-pulse

# åˆ›å»ºæ„å»ºç›®å½•
mkdir build && cd build

# é…ç½®
cmake ..

# ç¼–è¯‘
cmake --build . -j$(nproc)

# è¿è¡Œæµ‹è¯•
ctest --output-on-failure
```

### ä½¿ç”¨é¢„è®¾é…ç½®

```bash
# GCC æ„å»º
cmake --preset=gcc && cmake --build --preset=gcc

# Clang æ„å»º
cmake --preset=clang && cmake --build --preset=clang
```

### é›†æˆåˆ°ä½ çš„é¡¹ç›®

```cmake
# ä½œä¸ºå­æ¨¡å—æ·»åŠ 
add_subdirectory(async-pulse)

# é“¾æ¥ç›®æ ‡
target_include_directories(your_target PRIVATE async-pulse/src)
```

---

## ğŸ§ª æµ‹è¯•

å…¨é¢çš„æµ‹è¯•è¦†ç›–ç¡®ä¿ä»£ç å¯é æ€§ï¼š

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
ctest

# è¿è¡Œç‰¹å®šæµ‹è¯•å¥—ä»¶
ctest -R queue_ut
ctest -R thread_pool_ut

# ç›´æ¥è¿è¡Œæµ‹è¯•å¯æ‰§è¡Œæ–‡ä»¶
./build/bin/queue_ut --gtest_filter="*ms_queue*"
```

**æµ‹è¯•ç±»å‹**ï¼š
- âœ… å•å…ƒæµ‹è¯•ï¼šéªŒè¯å„ç»„ä»¶åŠŸèƒ½æ­£ç¡®æ€§
- âœ… å‹åŠ›æµ‹è¯•ï¼šé«˜å¹¶å‘åœºæ™¯ç¨³å®šæ€§æµ‹è¯•
- âœ… å†…å­˜æµ‹è¯•ï¼šæ”¯æŒ AddressSanitizer / ThreadSanitizer

---

## ğŸ“Š æ€§èƒ½åŸºå‡†

ä½¿ç”¨ Google Benchmark åœ¨ä»¥ä¸‹ç¯å¢ƒæµ‹è¯•ï¼š
- **CPU**: Intel Xeon @ 3.6GHz (8 æ ¸)
- **ç¼–è¯‘å™¨**: GCC 15.1.0
- **ç¼–è¯‘æ¨¡å¼**: Release (-O3)
- **æµ‹è¯•æ•°æ®ç±»å‹**: `int`

### å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€… (MPSC) ååé‡ â­ æœ€ä½³è¡¨ç°

æ—¥å¿—æ”¶é›†ç­‰å…¸å‹åœºæ™¯çš„ååé‡ï¼ˆè¶Šé«˜è¶Šå¥½ï¼‰ï¼š

| é˜Ÿåˆ—å®ç° | 2 çº¿ç¨‹ | 4 çº¿ç¨‹ | 16 çº¿ç¨‹ | æ‰©å±•æ€§ |
|---------|--------|--------|---------|--------|
| **`lock_free_bounded_queue`** | **2.89G** | **2.85G** | **2.23G** | **ä¼˜ç§€** |
| `lock_queue` | 2.72G | 2.74G | 1.97G | è‰¯å¥½ |
| `ms_queue` | 2.57G | 2.29G | 2.00G | è‰¯å¥½ |
| `lock_bounded_queue` | 2.63G | 2.61G | 2.23G | è‰¯å¥½ |

### å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€… (MPMC) ååé‡

å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…åœºæ™¯ä¸‹çš„ååé‡ï¼ˆå•ä½ï¼šitems/secondï¼‰ï¼š

| é˜Ÿåˆ—å®ç° | 2 çº¿ç¨‹ | 4 çº¿ç¨‹ | 16 çº¿ç¨‹ | æ‰©å±•æ€§ |
|---------|--------|--------|---------|--------|
| **`lock_free_bounded_queue`** | **2.34G** | **1.50G** | **979M** | **ä¼˜ç§€** |
| `lock_queue` | 2.23G | 1.39G | 1.10G | è‰¯å¥½ |
| `lock_bounded_queue` | 2.29G | 1.40G | 1.16G | è‰¯å¥½ |
| `ms_queue` | 2.11G | 1.56G | 1.02G | è‰¯å¥½ |

### å•ç”Ÿäº§è€…å¤šæ¶ˆè´¹è€… (SPMC) ååé‡

ä»»åŠ¡åˆ†å‘ç­‰åœºæ™¯çš„ååé‡ï¼š

| é˜Ÿåˆ—å®ç° | 2 çº¿ç¨‹ | 4 çº¿ç¨‹ | 16 çº¿ç¨‹ | æ‰©å±•æ€§ |
|---------|--------|--------|---------|--------|
| **`lock_free_bounded_queue`** | **1.56G** | **883M** | **182M** | **è‰¯å¥½** |
| `lock_queue` | 1.45G | 687M | 170M | ä¸€èˆ¬ |
| `ms_queue` | 1.45G | 666M | 194M | ä¸€èˆ¬ |
| `lock_bounded_queue` | 1.48G | 682M | 164M | ä¸€èˆ¬ |

### å•çº¿ç¨‹å¾€è¿”æµ‹è¯•

å•çº¿ç¨‹è¿ç»­æ‰§è¡Œå…¥é˜Ÿ+å‡ºé˜Ÿæ“ä½œçš„ååé‡ï¼š

| é˜Ÿåˆ—å®ç° | ååé‡ (ops/sec) | ç›¸å¯¹æ€§èƒ½ |
|---------|-----------------|---------|
| `lock_free_bounded_queue` | 184.2M | **1.80x** |
| `lock_queue` | 149.1M | 1.45x |
| `lock_bounded_queue` | 102.5M | **1.00x (åŸºå‡†)** |
| `ms_queue` | 15.7M | 0.15x |

### æ€§èƒ½åˆ†ææ€»ç»“

1. **MPSC åœºæ™¯**: `lock_free_bounded_queue` è¡¨ç°æœ€ä½³ï¼Œåœ¨ 2-16 çº¿ç¨‹èŒƒå›´å†…ååé‡ç¨³å®šåœ¨ **2.23G-2.89G items/sec**ï¼Œæ˜¯æ—¥å¿—æ”¶é›†ç­‰åœºæ™¯çš„é¦–é€‰
2. **å•çº¿ç¨‹åœºæ™¯**: `lock_free_bounded_queue` å‡­å€Ÿç¼“å­˜è¡Œå¯¹é½å’Œé¢„åˆ†é…å†…å­˜ï¼Œæ€§èƒ½æ˜¯ä¼ ç»Ÿ `lock_bounded_queue` çš„ **1.8 å€**
3. **é«˜å¹¶å‘ MPMC**: æ— é”é˜Ÿåˆ—åœ¨é«˜çº¿ç¨‹æ•°ä¸‹è¡¨ç°ç¨³å®šï¼Œé¿å…é”ç«äº‰å¯¼è‡´çš„æ€§èƒ½è¡°å‡
4. **æ‰©å±•æ€§**: æ— é”å®ç°åœ¨å„ç§å¹¶å‘åœºæ™¯ä¸‹å‡å±•ç°ä¼˜å¼‚æ‰©å±•æ€§ï¼Œååé‡ä¸ä¼šéšçº¿ç¨‹æ•°å¢åŠ è€Œæ˜¾è‘—ä¸‹é™

### æ€§èƒ½ä¼˜åŒ–å»ºè®®

- **å›ºå®šå®¹é‡åœºæ™¯**: ä¼˜å…ˆä½¿ç”¨ `lock_free_bounded_queue`ï¼Œæè‡´æ€§èƒ½ + æ— åŠ¨æ€åˆ†é…
- **åŠ¨æ€å®¹é‡åœºæ™¯**: ä½¿ç”¨ `ms_queue`ï¼Œæ— é”å®ç°ä¿è¯çº¿ç¨‹å®‰å…¨
- **ä½ç«äº‰åœºæ™¯**: `lock_queue` å®ç°ç®€å•ï¼Œæ€§èƒ½è¶³å¤Ÿ
- **ç¼“å­˜æ•æ„Ÿåº”ç”¨**: ä½¿ç”¨ç¼“å­˜è¡Œå¯¹é½é¿å…ä¼ªå…±äº«ï¼Œæå‡å¤šæ ¸æ‰©å±•æ€§

---

## ğŸ“ ä»£ç ç¤ºä¾‹

### ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

```cpp
#include "queue/lock_free_bounded_queue.h"
#include <thread>
#include <vector>

constexpr size_t CAPACITY = 1024;
lock_free_bounded_queue<int> queue(CAPACITY);

// ç”Ÿäº§è€…çº¿ç¨‹
auto producer = [&]() {
    for (int i = 0; i < 100000; ++i) {
        while (!queue.enqueue(i)) {
            // é˜Ÿåˆ—å·²æ»¡ï¼Œç­‰å¾…
        }
    }
};

// æ¶ˆè´¹è€…çº¿ç¨‹
auto consumer = [&]() {
    int val;
    for (int i = 0; i < 100000; ++i) {
        while (!queue.dequeue(val)) {
            // é˜Ÿåˆ—ä¸ºç©ºï¼Œç­‰å¾…
        }
        process(val);
    }
};

std::thread t1(producer);
std::thread t2(consumer);
t1.join();
t2.join();
```

### å¹¶è¡Œä»»åŠ¡å¤„ç†

```cpp
#include "thread_pool/thread_pool.h"
#include <vector>

struct Task {
    int id;
    int result;
};

ThreadPool<Task> pool(8, [](Task& t) {
    // æ¨¡æ‹Ÿè®¡ç®—å¯†é›†å‹ä»»åŠ¡
    t.result = heavy_computation(t.id);
});

std::vector<std::future<Task>> futures;
for (int i = 0; i < 100; ++i) {
    futures.push_back(pool.Submit(Task{i, 0}));
}

// æ”¶é›†ç»“æœ
for (auto& f : futures) {
    Task t = f.get();
    std::cout << "Task " << t.id << " result: " << t.result << std::endl;
}
```

---

## ğŸ—ºï¸ è·¯çº¿å›¾

- [ ] æ”¯æŒä¼˜å…ˆçº§çš„ä»»åŠ¡é˜Ÿåˆ—
- [ ] åŠ¨æ€çº¿ç¨‹æ•°é‡è°ƒæ•´
- [ ] å·¥ä½œçªƒå–ï¼ˆWork Stealingï¼‰è°ƒåº¦å™¨
- [ ] æ›´å¤šæ— é”æ•°æ®ç»“æ„ï¼ˆæ ˆã€é“¾è¡¨ã€å“ˆå¸Œè¡¨ï¼‰
- [ ] C++20 åç¨‹æ”¯æŒ

---

## ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨ [Apache 2.0](LICENSE) è®¸å¯è¯å¼€æºã€‚

---

<div align="center">

**â­ å¦‚æœè¿™ä¸ªé¡¹ç›®å¯¹ä½ æœ‰å¸®åŠ©ï¼Œè¯·ç»™æˆ‘ä»¬ä¸€ä¸ª Star!**

</div>
